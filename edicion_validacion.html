<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Proceso de acompa帽amiento coyuntural y automatizaci贸n de la Encuesta Nacional de Empleo</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <meta name="date" content="2020-09-01" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">



class: center, middle

.linea-superior[]
.linea-inferior[]


&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;


## Taller de R

## Validaci贸n y edici贸n de datos

## Proyecto Estat茅gico de Servicios Compartidos

### agosto 2020





---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Objetivo del taller

&lt;br&gt;
&lt;br&gt;
.center[

## *Entregar los conceptos necesarios para comprender el script de validaci贸n que veremos en la pr贸xima sesi贸n*
]

--

&lt;br&gt;
.center[
## Nos enfocaremos en tareas muy concretas, relacionadas con nuestro quehacer 
]
---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Asumiremos algunas cosas

## Todos tienen algo de experiencia usando `R`

--

- Todos saben lo que es un script y han trabajado de esta forma 

--

- Han trabajado con `dataframes` 

--

- Todos han trabajado con datos de encuestas de hogares (Stata, SPSS, Python, Excel)

--


- Todos saben c贸mo funciona un ciclo for (en Stata, R, Python o lo que sea)

--

&lt;br&gt;

.center[
## Si no manejan alguno de estos conceptos, no se preocupen. Haremos lo posible para que nadie quede atr谩s 
&lt;img src="imagenes/emoticon.PNG" width="100" /&gt;
]



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Contenidos de hoy

- Funciones b谩sicas de `dplyr` para editar datos

--

- Encadenamiento de instrucciones

--

- Explicaci贸n (veloz) del objeto lista 

--

- Introducci贸n a funcionales con `purrr` 

--

.center[
## El tiempo corre, as铆 que manos a la obra
]

.center[
&lt;img src="https://media.giphy.com/media/26n6xBpxNXExDfuKc/giphy.gif" width="400" /&gt;
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# 驴Qu茅 es dplyr y tidyverse?

&lt;br&gt;

.center[
&lt;img src="imagenes/paquetes.PNG" width="600" /&gt;
]

--

## Paquetes que comparten una filosof铆a

--

## Es importante limitarnos a este set de herramientas

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Diferencia entre dplyr y R base

Seleccionemos las mujeres mayores de 18 de una base de datos, conservando solo las columnas de sexo y edad

Con `R` base


```r
df &lt;- datos[datos$sexo == 2 &amp; datos$edad &gt; 18, c("sexo", "edad")]
```


--

Con `dplyr`


```r
datos %&gt;% 
  filter(sexo == 2 &amp; edad &gt; 18) %&gt;% 
  select(sexo, edad)
```


--

Si cada uno de nosotros elige su propio estilo, la comunicaci贸n se hace muy dif铆cil


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales funciones de dplyr

- `arrange`: ordena filas, usando alg煤n criterio

- `filter`: selecciona filas, usando alg煤n criterio

- `mutate`: crea variables a partir de las existentes

- `group_by`: agrupa filas, usando alg煤n criterio (similar a bys de Stata)

- `summarise`: reduce cada grupo a una fila, mediante el c谩lculo de una medida agregada

- `joins`: une filas de distintas tablas, usando una llave (similar a merge de Stata)



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales funciones de dplyr

Haremos una serie de procedimientos para ordenar una base de datos

Lo primero que haremos es seleccionar a la subpoblaci贸n que nos interesa: **personas adultas ocupadas**

--


```r
library(tidyverse);library(haven)

personas &lt;- read_dta("data/base-personas-viii-epf-(stata).dta")
names(personas) &lt;- tolower(names(personas)) #dejar nombres en min煤scula
*ocup_adultos &lt;- filter(personas, edad &gt;= 18 &amp; cae == 1 )
table(ocup_adultos$cae)
```

```
## 
##     1 
## 22519
```

--

El primer argumento de `filter` es un `dataframe` (personas)

--

El segundo argumento es una condici贸n (edad &gt;= 18 &amp; cae == 1 )

--

Noten que en `filter` las variables fueron llamadas sin el operador $ 

--

Podemos hacer la condici贸n tan compleja como nosotros queramos

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales funciones de dplyr

Quiero estimar una ecuaci贸n de salarios y necesito la edad al cuadrado. 

Tambi茅n necesito construir los ingresos de la ocupaci贸n principal y una variable dummy para sexo, que valga 1 para los hombres y 0 para las mujeres

--


```r
ocup_adultos &lt;-  mutate(ocup_adultos, 
                        edad2 = edad * edad, #alternativamente edad**2 o edad^2
                        ing = ingda_hd + ingdh_hd + ingnp_hd + ingdpi_hd,
                        sexo_d = if_else(sexo == 1, 1, 0)) 
```

--

Cada variable se va separando por comas

--

La funci贸n `if_else` opera de la misma manera que en excel 

--

Ahora me gustar铆a construir una base de datos m谩s compacta, solo con algunas columnas


```r
ocup_adultos &lt;- select(ocup_adultos, edad, edad2, sexo, ing, eduactual)
```

--

Finalmente, quiero ordenar los datos de menor a mayor, seg煤n edad


```r
ocup_adultos &lt;- arrange(ocup_adultos, desc(edad))
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales funciones de dplyr

Ahora que tengo mis datos m谩s o menos ordenados, quiero explorar un poco las variables 


```r
summarise(ocup_adultos, 
          media_edad = mean(edad), 
          media_ing = mean(ing))
```

```
## # A tibble: 1 x 2
##   media_edad media_ing
##        &lt;dbl&gt;     &lt;dbl&gt;
## 1       42.8   612393.
```

La funci贸n `summarise` compacta los datos en una fila, usando alguna funci贸n  

--

Debemos entender el nombre de manera literal, es decir, resumir 

--

.discussion[
Todas las funciones de `dplyr` tienen como primer argumento un `dataframe` y luego la instrucci贸n espec铆fica 
]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales funciones de dplyr

## Uniendo todo...


```r
ocup_adultos &lt;- filter(personas, edad &gt;= 18 &amp; cae == 1 ) 
table(ocup_adultos$cae)
ocup_adultos &lt;-  mutate(ocup_adultos, 
                   edad2 = edad * edad, #alternativamente edad**2 o edad^2
                   ing = ingda_hd + ingdh_hd + ingnp_hd + ingdpi_hd,
                   sexo_d = if_else(sexo == 1, 1, 0)) 
ocup_adultos &lt;- select(ocup_adultos, edad, edad2, sexo, ing, eduactual)
ocup_adultos &lt;- arrange(ocup_adultos, desc(edad))
summarise(ocup_adultos, media_edad = mean(edad), 
          media_ing = mean(ing))
```

--

.discussion[

Esta sucesi贸n de pasos funciona, sin embargo, no es la forma en la que usualmente trabajamos con `dplyr`

En internet no es com煤n ver este tipo de c贸digo
]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Encadenamiento de funciones

El operador `%&gt;%` (*pipe*) se usa para concatenar funciones

Usamos los (驴las?) *pipes* para pasar informaci贸n de un proceso a otro

--


```r
ocup_adultos &lt;- personas %&gt;% 
* filter(edad &gt;= 18 &amp; cae == 1 ) %&gt;%
  mutate(edad2 = edad * edad, 
         ing = ingda_hd + ingdh_hd + ingnp_hd + ingdpi_hd,
         sexo_d = if_else(sexo == 1, 1, 0)) %&gt;%
  select(edad, edad2, sexo, ing, eduactual) %&gt;%
  arrange(desc(edad))
```
--

Filtramos con `filter`

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Encadenamiento de funciones

El operador `%&gt;%` (*pipe*) se usa para concatenar funciones

Usamos los (驴las?) *pipes* para pasar informaci贸n de un proceso a otro


```r
ocup_adultos &lt;- personas %&gt;% 
  filter(edad &gt;= 18 &amp; cae == 1 ) %&gt;% 
* mutate(edad2 = edad * edad,
*        ing = ingda_hd + ingdh_hd + ingnp_hd + ingdpi_hd,
*        sexo_d = if_else(sexo == 1, 1, 0)) %&gt;%
  select(edad, edad2, sexo, ing, eduactual) %&gt;% 
  arrange(desc(edad))
```

Filtramos con `filter`

Creamos variables con `mutate`

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Encadenamiento de funciones

El operador `%&gt;%` (*pipe*) se usa para concatenar funciones

Usamos los (驴las?) *pipes* para pasar informaci贸n de un proceso a otro


```r
ocup_adultos &lt;- personas %&gt;% 
  filter(edad &gt;= 18 &amp; cae == 1 ) %&gt;% 
  mutate(edad2 = edad * edad, 
         ing = ingda_hd + ingdh_hd + ingnp_hd + ingdpi_hd,
         sexo_d = if_else(sexo == 1, 1, 0)) %&gt;%
* select(edad, edad2, sexo, ing, eduactual) %&gt;%
  arrange(desc(edad))
```

Filtramos con `filter`

Creamos variables con `mutate`

Seleccionamos variables con `select`

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Encadenamiento de funciones

El operador `%&gt;%` (*pipe*) se usa para concatenar funciones

Usamos los (驴las?) *pipes* para pasar informaci贸n de un proceso a otro


```r
ocup_adultos &lt;- personas %&gt;% 
  filter(edad &gt;= 18 &amp; cae == 1 ) %&gt;% 
  mutate(edad2 = edad * edad, 
         ing = ingda_hd + ingdh_hd + ingnp_hd + ingdpi_hd,
         sexo_d = if_else(sexo == 1, 1, 0)) %&gt;%
  select(edad, edad2, sexo, ing, eduactual) %&gt;% 
* arrange(desc(edad))
```

Filtramos con `filter`

Creamos variables con `mutate`

Seleccionamos variables con `select`

Ordenamos  con `arrange`


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# 驴C贸mo funcionan los pipes?

Podemos pensar en una secuencia de acciones:

.pull-left[
1. Sacar huevos del refigerador
2. Poner huevos en la sart茅n con aceite
3. Prender fuego
4. Revolver huevos
5. Comer

]

.pull-right[
&lt;img src="imagenes/huevo.PNG" width="250"/&gt;
]

--

Expresado en pseudo c贸digo


```r
comer(revolver(prender_fuego(poner_ensarten(sacar("huevos"), con = "aceite"))))
```

--

Expresado con *pipes*


```r
sacar("huevos") %&gt;% 
  poner_ensarten(con = "aceite") %&gt;% 
  prender_fuego() %&gt;% 
  revolver() %&gt;% 
  comer()
```
---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Un poco m谩s sobre los pipes


Los *pipes* sirven para que nuestro c贸digo sea mucho m谩s legible

--

Por una cuesti贸n de estilo y legibilidad es deseable escribir las funciones hacia abajo


&lt;img src="imagenes/correcto.PNG" width="50"/&gt;


```r
personas %&gt;% 
  filter(edad &gt;= 18 &amp; cae == 1 ) %&gt;% 
  select(edad, cae)
```

&lt;img src="imagenes/incorrecto.PNG" width="50"/&gt;


```r
personas %&gt;% filter(edad &gt;= 18 &amp; cae == 1 ) %&gt;% select(edad, cae)
```

--
.center[
&lt;img src="imagenes/shortcut.PNG" width="450" /&gt;
]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ahora les toca a ustedes

Carguen la base de personas

```r
library(tidyverse);library(haven)
personas &lt;- read_dta("data/base-personas-viii-epf-(stata).dta")
names(personas) &lt;- tolower(names(personas)) #dejar nombres en min煤scula
```

Intenten concatenar las siguientes instrucciones

1. Filtrar solo a los hombres
2. Crear una variable llamada joven que valga 1 si la persona es menor o igual 35 y 0, si es mayor.
3. Seleccionar las siguientes variables: folio, edad, joven
4. Asignar todo eso a un nuevo objeto llamado df

Deber铆an basarse en el c贸digo de la l谩mina anterior

--

```r
df &lt;- personas %&gt;% 
  filter(sexo == 1) %&gt;% 
  mutate(joven = if_else(edad &lt;= 35, 1, 0)) %&gt;% 
  select(folio, edad, joven)
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales funciones de dplyr

En encuestas de hogares, usualmente queremos construir valores a nivel de hogar. Por ejemplo, **ingreso total**

--

Para ello, usamos la funci贸n `group_by`

--

.pull-left[
![](https://i2.wp.com/cmdlinetips.com/wp-content/uploads/2018/02/split_apply_combine_example.jpg?resize=478%2C298)
]

.pull-right[

- Primero `group_by` divide el *data frame*.

- Luego opera una funci贸n con la data fragmentada.

- Finalmente `group_by` vuelve a combinar los resultados.
]

--


```r
df &lt;- personas %&gt;% 
  mutate(ing = ingda_hd + ingdh_hd + ingnp_hd + ingdpi_hd) %&gt;% 
* group_by(folio) %&gt;%
* mutate(ing_hog = sum(ing))
```
--

Todo lo que hagamos despu茅s de `group_by` va a ejecutarse sobre dicha agregaci贸n

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales funciones de dplyr

Veamos otro ejemplo de `group_by`

--

Queremos calcular el ingreso promedio por hogar, seg煤n 谩rea de estimaci贸n

--


```r
personas %&gt;% 
  mutate(ing = ingda_hd + ingdh_hd + ingnp_hd + ingdpi_hd) %&gt;% 
  group_by(folio) %&gt;% 
  mutate(ing_hog = sum(ing)) %&gt;%  
* slice(1) %&gt;%
* group_by(zona)  %&gt;%
* summarise(media_zona = mean(ing_hog))
```

```
## # A tibble: 2 x 2
##                                zona media_zona
##                           &lt;dbl+lbl&gt;      &lt;dbl&gt;
## 1 1 [Gran Santiago]                    944790.
## 2 2 [Resto de Capitales Regionales]    862610.
```

`slice` selecciona *n* filas de cada grupo. En este caso seleccionamos la primera

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ahora les toca a ustedes

Usando la base de personas, calculemos la edad promedio, seg煤n sexo y zona. Para ello deben:

1. Agrupar
2. Calcular media

**Pista**: la funci贸n `group_by` puede recibir *n* variables

--


```r
personas %&gt;% 
  group_by(sexo, zona) %&gt;% 
  summarise(edad_media = mean(edad))
```

```
## # A tibble: 4 x 3
## # Groups:   sexo [2]
##         sexo                              zona edad_media
##    &lt;dbl+lbl&gt;                         &lt;dbl+lbl&gt;      &lt;dbl&gt;
## 1 1 [Hombre] 1 [Gran Santiago]                       34.6
## 2 1 [Hombre] 2 [Resto de Capitales Regionales]       34.5
## 3 2 [Mujer]  1 [Gran Santiago]                       38.0
## 4 2 [Mujer]  2 [Resto de Capitales Regionales]       37.1
```





---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Principales funciones de dplyr

## Una tarea muy com煤n es unir tablas  

--

No queremos que nos vaya a pasar...

.center[
&lt;img src="https://media.giphy.com/media/cFkiFMDg3iFoI/giphy.gif" width="350" /&gt;
]

--

O esto...


.center[
&lt;img src="https://media0.giphy.com/media/P4TqKx6NHyLnO/giphy.gif?cid=3640f6095c91abd67a467174592b5512" width="350" /&gt;
]



---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Familia join

--

.pull-left[

- `left_join`

- `right_join`

- `inner_join`

- `full_join`

- otros m谩s

]

.pull-right[
&lt;img src="imagenes/joins.PNG" width="1000" /&gt;
]

--

Nosotros veremos 煤nicamente `left_join` e `inner_join`, pero les recomiendo mucho revisar los otros tipos


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Familia join (left_join)

.pull-left[
.discussion[
Conserva todas las filas de la base "de la izquierda"

Excluye las filas del lado derecho que no hagan *match* 
]
]

.pull-right[
&lt;img src="imagenes/left_join.PNG" width="300" /&gt;
]

--

Vamos a crear una base ficticia que est茅 a nivel de hogares

```r
hogares &lt;- personas %&gt;% 
  group_by(folio) %&gt;% 
  slice(1) %&gt;% 
  select(folio, ing_total_hog_hd) 

head(hogares, 2)
```

```
## # A tibble: 2 x 2
## # Groups:   folio [2]
##   folio   ing_total_hog_hd
##   &lt;chr&gt;              &lt;dbl&gt;
## 1 00001-1         1588000 
## 2 00002-1          670060.
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Familia join (left_join)



```r
personas2 &lt;- personas %&gt;% 
  left_join(hogares, by = "folio")
```

- Primer argumento: `dataframe` "de la izquerda"

- Segundo argumento: `dataframe` "de la derecha"

- Tercer argumento: llave que permite la uni贸n

--

**Ojo**: cuando 2 columnas tienen el mismo nombre en ambas tablas, R agrega un sufijo


```
## # A tibble: 2 x 3
*##   folio   ing_total_hog_hd.x ing_total_hog_hd.y
##   &lt;chr&gt;                &lt;dbl&gt;              &lt;dbl&gt;
## 1 00001-1            1588000            1588000
## 2 00001-1            1588000            1588000
```


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Familia join (left_join)

Vamos a agregar nuevos registros a la tabla de la derecha y hacemos `left_join`

--


```r
hogares_alterado &lt;- hogares %&gt;% 
  bind_rows(data.frame(folio = c("99999999999-1", "999999999999-99"), 
                       ing_total_hog_hd = c(1, 2)))

personas2 &lt;- personas %&gt;% 
  left_join(hogares_alterado, by = "folio")

dim(personas2)[1]
dim(personas)[1]
```

驴personas2 y personas tendr谩n igual o distinto n煤mero de filas?

--


```
## [1] 48308
```

```
## [1] 48308
```

--

Seguimos teniendo la misma cantidad de filas 

`left_join` descarta los registros de la derecha que no hacen match

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Familia join (inner_join)

.pull-left[
.discussion[

`inner_join` conserva solo las filas que coinciden en ambas tablas 

Es posible que las filas de la tabla final no coincida con ninguna de las originales 

]
]
.pull-right[
&lt;img src="imagenes/inner_join.PNG" width="300" /&gt;
]

--

Vamos a seleccionar aleatoriamente filas de ambas tablas

```r
set.seed(123)
hogares_alterado &lt;- hogares %&gt;%
  ungroup() %&gt;% 
  slice_sample(prop = 0.5)
set.seed(123)  
personas_alterado &lt;- personas %&gt;% 
  ungroup() %&gt;% 
  slice_sample(prop = 0.5)

l1 &lt;- length(unique(hogares_alterado$folio))
l2 &lt;- length(unique(personas_alterado$folio))
c(l1, l2)
```

```
## [1]  7619 12467
```
---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Familia join (inner_join)

Hacemos `inner_join` para ver qu茅 ocurre


```r
personas2 &lt;- personas_alterado %&gt;% 
  inner_join(hogares_alterado, by = "folio")

length(unique(personas2$folio))
```

```
## [1] 6213
```

--

Solo 6213 hogares se mantienen en la tabla final



---
.linea-superior[]
.linea-inferior[]


## Algunas referencias para seguir aprendiendo  `dplyr`

- [R for data science](https://r4ds.had.co.nz/relational-data.html) (disponible en espa帽ol)

- [Torpedos](https://rstudio.com/resources/cheatsheets/) (varios t贸picos)

- [Statistical Inference via Data Science](https://moderndive.com/3-wrangling.html) 

- Para cosas puntuales usen [stackoverflow](https://es.stackoverflow.com/) en ingl茅s

--

Sugerencia para *googlear*: "data wrangling dplyr"

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicios para aplicar dplyr

Usando la base de personas y gastos de la VIII EPF:

1. Calculen el gasto promedio de los hogares por divisi贸n y zona (deben quedar dos filas por cada divisi贸n)
2. Calculen la suma del gasto por hogar en la divisi贸n 1 (debe quedar una observaci贸n por hogar)
3. Unir el gasto calculado de la divisi贸n 1 con la base de personas

--

**Nota**: en primera instancia, no se preocupen de los factores de expansi贸n, pero si se animan, es un muy buen ejercicio hacer los c谩lculos considerando la expansi贸n.

--

Para cumplir con la tarea, deber谩n usar casi todas las funciones que vimos hoy, en especial: `group_by`,
`summarise` y `left_join` 

--

Es posible que algunas partes no sean tan f谩ciles, pero no se rindan. Sufrir un rato tiene su recompensa 

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resoluci贸n ejercicio


```r
#gastos &lt;- read_dta("data/base-gastos-viii-epf-(stata).dta")
#Tarea 1
names(gastos) &lt;- tolower(names(gastos))
promedio_gasto &lt;- gastos %&gt;% 
  filter(folio != "" &amp; d != "") %&gt;% #eliminar challa
  group_by(folio) %&gt;% 
  mutate(n = row_number() == 1) %&gt;% 
  group_by(zona) %&gt;% 
  mutate(hogares_zona = sum(n)) %&gt;% 
  group_by(d, zona) %&gt;% 
  mutate(gasto_medio = sum(gasto) / hogares_zona) %&gt;% 
  slice(1) %&gt;% 
  select(zona, d,hogares_zona, gasto_medio)

#Tarea 2
gasto_div1 &lt;- gastos %&gt;% 
  filter(folio != "" &amp; d != "") %&gt;% #eliminar challa
  filter(d == "01") %&gt;% #OJO: se pierden algunos folios
  group_by(folio) %&gt;% 
  mutate(suma_d1 = sum(gasto)) %&gt;% 
  slice(1) %&gt;% 
  select(folio, suma_d1)

#Tarea 3
final &lt;- personas %&gt;% 
  left_join(gasto_div1, by = "folio") %&gt;% 
  mutate(suma_d1 = if_else(is.na(suma_d1), 0, suma_d1)) #hogares que no pegaron
```



---
.linea-superior[]
.linea-inferior[]

.texto_intermedio[
Pasemos a ver qu茅 son las listas

]

.center[
&lt;img src="imagenes/listas.PNG" width="600" /&gt;
]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Aprendiendo sobre listas

Las listas son uno de los tipos de datos fundamentales en `R` 

--

Tienen una gran flexibilidad

--

Nos permiten almacenar datos de diferente tipo y longitud



```r
mi_lista &lt;- list(c(1,2,3), "Mingus", personas)
length(mi_lista)
```

```
## [1] 3
```
--
Podemos acceder a los elementos de nuestra lista a trav茅s de sus 铆ndices

--

驴Qu茅 creen que va a devolver esta l铆nea de c贸digo?


```r
mi_lista[[2]]
```
--

```
## [1] "Mingus"
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Aprendiendo sobre listas

Tambi茅n podemos acceder a lo que sea que contengan los 铆ndices


```r
mi_lista[[1]][3]
```

```
## [1] 3
```
--

Y adem谩s transformar los elementos dentro de la lista


```r
mi_lista[[1]][3] &lt;- 99
mi_lista[[1]]
```

```
## [1]  1  2 99
```

--

Para poner nombres a la lista podemos hacer lo siguiente


```r
names(mi_lista) &lt;- c("uno", "dos", "tres")
mi_lista[["uno"]]
```

```
## [1]  1  2 99
```

```r
mi_lista$uno
```

```
## [1]  1  2 99
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ahora les toca a ustedes

Creen una lista con los siguientes elementos y as铆gnenla a un objeto llamado mi_lista:


```r
animales &lt;- c("perro", "gato")
escritores &lt;- c("hemingway", "manuel rojas", "nona fernandez", "faulkner", "harper lee")
grito &lt;- "aaaaaaah"
numeros &lt;- 1:100
```

1. Cuenten cu谩ntos elementos tiene la lista
2. Asignen nombres a cada uno de los elementos (los que ustedes quieran)
3. Accedan al cuarto elemento del vector de escritores y mu茅strenlo en pantalla
4. Cambien grito por el siguiente string: "me siento 帽o帽o aprendiendo R"
5. Cambien el listado de n煤meros por un vector del 1 al 10

--


```r
mi_lista &lt;- list(animales, escritores, grito, numeros)
length(mi_lista)
names(mi_lista) &lt;- c("animales", "escritores", "grito", "numeros")
mi_lista[[2]][4] #priemra forma de acceder
mi_lista$grito &lt;- "me siento 帽o帽o aprendiendo R" #segunda forma de acceder
mi_lista[["numeros"]] &lt;- c(1:10) #tercera forma de acceder
```



---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Introducci贸n a funcionales con purrr

*To become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs.*

-Bjarne Stroustrup (creador de C++)

--

Las funcionales (functionals) son funciones que reciben como argumento otra funci贸n y retornan un vector



```r
random &lt;- function(f) f(runif(10))
random(mean)
```

```
## [1] 0.5575298
```
--

.center[
&lt;img src="https://media.giphy.com/media/uYgYvxxhCf3e8/giphy.gif" width="280" /&gt;
]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Para no ponernos nerviosos

Los contenidos de esta clase son m谩s avanzados que los de la sesi贸n anterior, pero no hay motivo para ponernos ansiosos

--

.center[
&lt;img src="https://media.giphy.com/media/1FMaabePDEfgk/giphy.gif" width="250" /&gt;
]

--

Es probable que no todo se entienda inmediatamente, pero no hay nada de malo en eso

--

.center[
&lt;img src="https://media.giphy.com/media/YEongvRqe8sXC/giphy.gif" width="280" &gt;
] 

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Antes de seguir...


驴Alguno de ustedes tiene una idea de qu茅 hace este c贸digo?


```r
for (i in 1:10) {
  print(i)
}
```

--

El valor de `i` ir谩 tomando valores de 1 al 10


--


```r
escritores &lt;- c("hemingway", "orwell", "nona fernandez", "faulkner", "harper lee")
for (escritor in escritores) {
  print(paste0(escritor, " escribi贸 varias novelas")) 
}
```

```
## [1] "hemingway escribi贸 varias novelas"
## [1] "orwell escribi贸 varias novelas"
## [1] "nona fernandez escribi贸 varias novelas"
## [1] "faulkner escribi贸 varias novelas"
## [1] "harper lee escribi贸 varias novelas"
```

--

Veremos que las funcionales en `R` son simplemente otra manera de implementar la idea de iteraci贸n


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# 驴Por qu茅 usamos funcionales?

*For loops have a bad rap in R because many people believe they are slow, but the real downside of for loops is that theyre very flexible: a loop conveys that youre iterating, but not what should be done with the results.*


*Each functional is tailored for a specific task, so when you recognise the functional you immediately know why its being used.*

.center[
&lt;img src="imagenes/hadley.PNG" width="200" /&gt;
]

--

 **Nota:** un ciclo for puede llegar a ser realmente lento en R, si se usa mal. Usado correctamente, no deber铆a ser peor que una funcional. 


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# 驴Por qu茅 usamos funcionales?



```r
datos &lt;-  list(df1 = data.frame(x = c(1, 2, 7)), df2 = data.frame(x = c(3, 4))) 
datos
```

```
## $df1
##   x
## 1 1
## 2 2
## 3 7
## 
## $df2
##   x
## 1 3
## 2 4
```

--

Queremos evitar c贸digo dif铆cil de entender y que esconde errores 


```r
i &lt;- 1
new_data &lt;- vector(length = length(datos), mode = "list")
for (df in datos) {
  if (nrow(df) &gt; 2) {
    new_data[[i]] &lt;- df %&gt;% 
      mutate(y = x + mean(x) )
  }
  i = i + 1
}
```


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# 驴Por qu茅 usamos funcionales?


Cuando existen *loops* anidados y condiciones m谩s complejas, pueden pasar varias cosas:

- Es muy f谩cil cometer errores y muy dif铆cil encontrarlos 

- Es posible cometer errores y no darnos cuenta

- Puede ser dif铆cil anticipar el resultado del c贸digo

--

Queremos escribir algo como esto


```r
crear_si &lt;- function(df) {
  if (nrow(df) &gt; 2) {
     df %&gt;% 
      mutate(y = x + mean(x) )
  } 
}

new_data &lt;- map(datos, crear_si)
```


 

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Funcionales con R base

R base ofrece maneras de implementar funcionales:

.pull-left[

- apply

- lapply

- mapply

- sapply 

- entre otras
]

--

.pull-right[
Funcionan bien, pero tienen algunas inconsistencias respecto a la sintaxis y a los tipos de datos que retornan.   

Para usar funcionales en estilo tidyverse contamos con el paquete `purrr` 
]

--

.center[
&lt;img src="imagenes/purrr.PNG" width="200" /&gt;

]


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# 驴Por qu茅 hablamos de mapas?

Mapear es llevar algo de un lugar a otro


.pull-left[
&lt;img src="imagenes/funcional.PNG" width="250" /&gt;
]
 
.pull-right[
Estamos "mapeando" valores a funciones 

.discussion[
Una funcional es una manera diferente de implementar el concepto de iteraci贸n
]

]

--


```r
triple &lt;- function(x) {x * 3} 
map(1:3, triple)
```

```
## [[1]]
## [1] 3
## 
## [[2]]
## [1] 6
## 
## [[3]]
## [1] 9
```
---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Par茅ntesis de funciones

En `R` implementamos funciones del siguiente modo 

```r
doblar &lt;- function(x) {
  return(2 * x)
}
```

--

Para llamar a la funci贸n, hacemos lo siguiente


```r
doblar(3)
```

```
## [1] 6
```

--

Si a alguien le interesa, otro d铆a podemos conversar m谩s sobre funciones 

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Calculando promedios con map

Queremos calcular el promedio de varias columnas


```r
ingresos &lt;- personas %&gt;% 
  select(ing_total_hog_hd, ing_disp_hog_hd_ai, ing_primario_hog_hd)

map(ingresos, mean) 
```

```
## $ing_total_hog_hd
## [1] 1462938
## 
## $ing_disp_hog_hd_ai
## [1] 1454598
## 
## $ing_primario_hog_hd
## [1] 1302252
```
Lo que hace `map` es evaluar la funci贸n `mean` en cada una de las columnas del `dataframe`

--

Pueden entenderlo como que estamos "pas谩ndole a la funci贸n diferentes valores" y `map` nos devuelve el resultado de la evaluaci贸n en un **objeto lista**

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Variantes de map

En el ejemplo anterior el resultado era una lista gen茅rica.

`map` nos permite devolver distintos vectores


- map_chr

- map_lgl

- map_int

- map_dbl


```r
map_dbl(ingresos, mean) 
```

```
##    ing_total_hog_hd  ing_disp_hog_hd_ai ing_primario_hog_hd 
##             1462938             1454598             1302252
```


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Conflictos

Si existe conflicto entre el vector que le pedimos a `map` y los valores de la funci贸n evaluada, obtendremos un error


```r
map_int(ingresos, mean) 
```

```
## Error: Can't coerce element 1 from a double to a integer
```

--

El objeto retornado tiene decimales y estamos pidiendo que nos devuelva un vector de enteros

Esto es una de las cosas buenas de `purrr`

- Lo que retorna cada funci贸n siempre est谩 claro

--

- Nos obliga a ser consistentes en el trabajo que hacemos

--

- Los errores en programaci贸n son parte de la vida

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ahora les toca a ustedes

1. Usando `map`, queremos ver cu谩l es el tipo de dato de cada una de las columnas del `dataframe` personas. Para ello, usa la funci贸n `typeof`

2. Genera una base a nivel de hogar, conservando las siguientes columnas: ing_disp_hog_hd, ing_disp_hog_hd_ai y ing_disp_hog_hd_pc. Luego, aplica una normalizaci贸n a cada una de ellas. La normalizaci贸n que usaremos es la siguiente:

.center[
`\(\frac{(x_i-media(x))}{sd(x)}\)`
]



Asigna el resultado de tu c贸digo a un objeto llamado df. 

--

**Nota 1**: Hice una plantilla de la funci贸n `normalizar`. Ustedes deben completarla

**Nota 2**: Si tienen un problema con `group_by`, echen mano a lo que vimos la semana pasada 

--


```r
#Funci贸n para normalizar
normalizar &lt;-  function(x) {
  #aqu铆 va tu c贸digo
}
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Soluci贸n ejercicio



```r
#Ejercicio 1
map(personas, typeof) 

#Ejercicio 2
df &lt;- personas %&gt;% 
  group_by(folio) %&gt;% 
  slice(1) %&gt;% 
  ungroup() %&gt;% 
  select(ing_disp_hog_hd, ing_disp_hog_hd_ai, ing_disp_hog_hd_pc) %&gt;% 
  map(normalizar)
```

`normalizar` se aplica a las 3 columnas 

 Recuerden que `select` por defecto selecciona las variables de agrupaci贸n   


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Agreguemos m谩s argumentos

驴Qu茅 pasa si nuestra funci贸n recibe m谩s de un argumento?

--

La funci贸n `mean` puede recibir el par谩metro na.rm para ignorar los `NA`

--

Vamos a introducir algunos valores `NA`


```r
personas %&gt;% 
  group_by(folio) %&gt;% 
  slice(1) %&gt;% 
  ungroup() %&gt;% 
  select(ing_disp_hog_hd, ing_disp_hog_hd_ai, ing_disp_hog_hd_pc) %&gt;% 
* mutate(ing_disp_hog_hd = if_else(ing_disp_hog_hd &lt;= 300000, NA_real_, ing_disp_hog_hd )) %&gt;%
* map(mean, na.rm = T)
```

```
## $ing_disp_hog_hd
## [1] 1312287
## 
## $ing_disp_hog_hd_ai
## [1] 1344931
## 
## $ing_disp_hog_hd_pc
## [1] 420915.8
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Agreguemos m谩s argumentos

.pull-left[
&lt;img src="imagenes/funcional2.PNG" width="300" /&gt;
]

--

.pull-right[
El orden de los argumentos es el siguiente:

1. dataframe
2. funci贸n
3. argumento de la funci贸n
]



```r
map(personas, mean, na.rm = T ) 
```


En este caso el argumento est谩 fijo, es decir, aplica para todas las iteraciones

--

驴Qu茅 pasa si queremos que este argumento vaya variando?

.center[
&lt;img src="https://media.giphy.com/media/a5viI92PAF89q/giphy.gif" width="200" /&gt;
]


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Agreguemos argumentos m贸viles

A veces, queremos que el argumento de la funci贸n vaya variando



```r
escritores &lt;- c("hemingway", "orwell", "nona fernandez", "faulkner", "harper lee")

for (i in 1:5) {
  print(c(i, escritores[i]))
}
```

```
## [1] "1"         "hemingway"
## [1] "2"      "orwell"
## [1] "3"              "nona fernandez"
## [1] "4"        "faulkner"
## [1] "5"          "harper lee"
```

--

En nuestra estructura de `map` no es posible hacer esto

--

Necesitamos algo m谩s poderoso y `map2` es la respuesta


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Agreguemos argumentos m贸viles

.center[
&lt;img src="imagenes/map2.PNG" width="350" /&gt;
]

Tenemos una funci贸n que toma dos valores y los imprime dentro de un vector 


```r
ejemplo &lt;- function(x, y) {print(c(x, y))}
result &lt;- map2(escritores, 1:5, ejemplo)  
```

```
## [1] "hemingway" "1"        
## [1] "orwell" "2"     
## [1] "nona fernandez" "3"             
## [1] "faulkner" "4"       
## [1] "harper lee" "5"
```


`map2` va recorriendo simult谩neamente el vector escritores y el vector num茅rico (1 a 5) 

--

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Desaf铆o walk

Alternativamente, pueden usar `walk` y `walk2` combinada con una funci贸n an贸nima. No es fundamental y queda como desaf铆o personal 


```r
walk2(escritores, 1:5, function(x, y) print(c(x, y))  )
```

--

[walk](https://www.youtube.com/watch?v=LWZTzdwRCSQ) 

.center[
&lt;img src="imagenes/pantera.PNG" width="350" /&gt;
]


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tarea para la casa

1) En su directorio de trabajo (es deseable que sea un proyecto) creen la siguiente ruta: "data/ejercicio"

2) Ejecuten el siguiente c贸digo



```r
personas &lt;- read_dta("data/base-personas-viii-epf-(stata).dta")
names(personas) &lt;- tolower(names(personas))
varstrat &lt;- sort(unique(personas$varstrat))

filter_save &lt;- function(df, num) {
  num_enquo &lt;- enquo(num)
  data &lt;- df %&gt;% 
    filter(varstrat == !!num_enquo) %&gt;% 
    select(folio, varstrat)
  file_name &lt;- paste0("data/ejercicio/estrato_", num, ".RData")
  save(data, file = file_name)
}

walk(varstrat,  filter_save, df = personas )
```

El resultado ser谩n 65 archivos en la carpeta ejercicio

**3) Utilizando el paquete `purrr`, carguen toda las tablas generadas en un objeto llamado tablas_epf**


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tarea para la casa

**Pista 1**: Encuentren el patr贸n que hace posible cargar todas las tablas

**Pista 2**: La funci贸n `filter_save` no es el foco de la tarea. Hay conceptos que no hemos revisado y pueden gastar mucho tiempo entiendo cada l铆nea, pero alguna de ellas les puede servir .   

**Nota 1**: La respuesta ocupa tan solo 4 l铆neas, pero requiere internalizar y aplicar varios conceptos. Ah铆 est谩 el desaf铆o.  

**Nota 2**: Este ejercicio es sustantivamente m谩s complejo que el de la semana pasada. En Internet van a encontrar la respuesta f谩cilmente, pero eso no les va a servir para internalizar los conceptos. Vean la respuesta solo despu茅s de haber intentado un rato.  

A veces, se aprende m谩s **no** resolviendo un problema durante un rato, que yendo directamente a la respuesta en Internet.  



---

class: center, middle

.linea-superior[]
.linea-inferior[]
&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;



## Gracias


---

.linea-superior[]
.linea-inferior[]


```r
concatenar &lt;- function(x, y) {
  c(x, y)
}

iterar &lt;- function(x) {
  map(1:3, concatenar, x = x  )
}

x &lt;- map(1:2, function(x) {
  map(1:3, function(y) c(x, y))
  } 
)

x &lt;- map(1:2, function(x) {
  map(1:3, concatenar, x = x  )
  } 
)

x &lt;- map(1:2, iterar)
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
